<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TXT 파일 변환</title>
    <!-- 공통 스타일과 변환 페이지 전용 스타일을 링크합니다. -->
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/convert.css">
</head>
<body>
    <!-- 헤더: 모든 페이지에서 공통으로 사용 -->
    <header class="app-header">
        <div class="logo">
            <a href="index.html">WEBEQ STUDIO</a>
        </div>
        <nav class="navigation">
            <a href="eq.html" class="nav-btn">EQ</a>
            <a href="convert.html" class="nav-btn active">Transform</a>
        </nav>
    </header>

    <main class="main-content">
        <div class="conversion-container">
            <!-- 파일 업로드 영역 -->
            <div id="upload-area" class="upload-area">
                <div class="upload-icon">↑</div> <!-- 아이콘은 간단한 문자로 대체 또는 SVG/이미지 사용 가능 -->
                <p>REW 측정 또는 EQ 필터 TXT 파일을<br>여기에 드래그앤드롭 하세요.</p>
                <strong id="upload-text">파일 업로드</strong>
            </div>
        </div>
        <div class="conversion-container">
            <!-- EQ에서 불러오기 영역 -->
            <div class="format-selection">
                <h3>PEQ에서 가져오기</h3>
                <textarea id="txt_load_from_peq" class="load-from-eq-btn load-from-eq-preview"></textarea>
                <button id="btn_load_from_peq" class="load-from-eq-btn">EQ 설정파일 불러오기</button>
            </div>
        </div>
        <div class="conversion-container">
            <!-- 포맷 선택 영역 -->
            <div class="format-selection">
                <h3>변환할 타겟 포맷 선택</h3>
                <ul id="format-list" class="format-list">
                    <li>miniDSP용 TXT 포맷</li>
                    <li>Hypex DSP용 XML 포맷</li>
                    <li>Generic Biquad CSV 포맷</li>
                    <li format="REW">REW 스크립트 출력</li>
                </ul>
            </div>
        </div>
    </main>

    <!-- === JAVASCRIPT === -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const uploadArea = document.getElementById('upload-area');
            const uploadText = document.getElementById('upload-text');
            const formatList = document.getElementById('format-list');
			const peqLoadTxt = document.querySelector('#txt_load_from_peq');
			const peqLoadBtn = document.querySelector('#btn_load_from_peq');
			
			// PEQ 데이터 불러오기 버튼을 눌렀을 때
			peqLoadBtn.onclick = () => {
				const userId = localStorage.getItem('webeq_userid');
				if (!userId) {
					alert("저장된 PEQ 설정 정보를 불러올 수 없습니다");
					return;
				}

				const data = {}
				data.userid = userId;

				const response = fetch('/sest', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify(data)
				});
				
				response.then((resp) => {
					if (resp.ok) {
						const recvdata = resp.json();
						recvdata.then((d) => {
							if (d && Object.hasOwn(d, 'eqsettingdata'))
								peqLoadTxt.value = d.eqsettingdata;
						});
					}
				});
			};

            // --- 드래그 앤 드롭 시각적 효과 ---
            // 브라우저 기본 동작 방지 (파일 열기)
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.body.addEventListener(eventName, e => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            // 드래그 영역에 들어왔을 때
            uploadArea.addEventListener('dragenter', () => {
                uploadArea.classList.add('drag-over');
            });

            // 드래그 영역을 떠났을 때
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('drag-over');
            });

            // 파일이 드롭되었을 때
            uploadArea.addEventListener('drop', (e) => {
                uploadArea.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    // 실제 파일 처리 로직은 여기에 추가
                    // 예: 첫 번째 파일 이름 표시
                    uploadText.textContent = `파일: ${files[0].name}`;
                    console.log('Dropped file:', files[0]);
                }
            });

            // --- 포맷 리스트 클릭 효과 ---
            formatList.addEventListener('click', (e) => {
                if (e.target.tagName === 'LI') {
                    // 모든 li에서 active 클래스 제거
                    formatList.querySelectorAll('li').forEach(li => {
                        li.classList.remove('active');
                    });
                    // 클릭된 li에만 active 클래스 추가
                    e.target.classList.add('active');

                    // 선택된 포맷에 대한 로직 추가 가능
                    switch (e.target.getAttribute("format")) {
                        case "REW":
                            if (!peqLoadTxt.value)
                                return;

                            if (peqLoadTxt.value.length == 0)
                                return;

                            // Blob 객체 생성 (텍스트 타입으로)
                            const blob = new Blob([peqLoadTxt.value], {type: 'text/plain;charset=utf-8'});

                            // 임시 URL 생성
                            const url = URL.createObjectURL(blob);

                            // <a> 태그 동적 생성
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'rew_format.txt';  // 다운로드될 파일 이름
                            document.body.appendChild(a);   // DOM에 추가 (클릭을 위해 필요)

                            // 자동 클릭으로 다운로드 트리거
                            a.click();

                            // 정리: URL 해제 및 요소 제거
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            break;
                    }
                }
            });
        });
    </script>
</body>
</html>